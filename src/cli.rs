use core::fmt;
use std::{ops::Deref, path::PathBuf};

use clap::Parser;
use serde::Deserialize;

use crate::{config::get_configuration, output::Profile};

/// A wrapper around a `Option<PathBuf>` that implements `From<&str>` and `Display` so that Clap is
/// happy.
#[derive(Debug, Clone, Deserialize)]
struct ClapPath(Option<PathBuf>);

impl Deref for ClapPath {
    type Target = Option<PathBuf>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<&str> for ClapPath {
    fn from(s: &str) -> Self {
        ClapPath(Some(PathBuf::from(s)))
    }
}

impl fmt::Display for ClapPath {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match &self.0 {
            Some(path) => write!(f, "{}", path.display()),
            None => write!(f, "None"),
        }
    }
}

#[derive(Parser)]
struct Args {
    /// The name of the new profile.
    profile: String,

    /// Save the profile to the configuration directory.
    #[clap(short, long)]
    save: bool,

    /// When saving, allow overwriting an existing profile of the same name.
    #[clap(short, long)]
    force: bool,

    /// The suffix added to the profile filename when saving.
    #[clap(long, default_value = ".conf")]
    suffix: String,

    /// The directory where the profile should be saved.
    #[clap(short, long, default_value_t = ClapPath(dirs::config_dir().map(|v| v.join("kanshi/config.d"))))]
    config_dir: ClapPath,

    /// The input file to read the current display configuration from. The file should be valid
    /// JSON created from `swaymsg -t get_outputs --raw`.
    ///
    /// If not specified, the configuration is fetched automatically from the Sway IPC. If the
    /// input file is `-`, the configuration is instead read from stdin.
    #[clap(long)]
    from_file: Option<String>,

    /// Show where the profile generated by a given invocation would be saved, if --save is used.
    ///
    /// The profile will not be saved if this flag is used.
    #[clap(short, long)]
    location: bool,
}

/// Entrypoint for the CLI.
pub fn run() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    if args.force && !args.save {
        eprintln!("The --force flag cannot be used without --save.");
        std::process::exit(1);
    }

    let filename = format!("{}{}", &args.profile, args.suffix);
    let config_dir = args.config_dir.as_ref().expect("a config directory was able to be determined");
    let profile_path = config_dir.join(&filename);

    if args.location {
        println!("{}", profile_path.display());
        return Ok(());
    }

    let configuration = get_configuration(args.from_file.as_deref())?;
    let profile = match Profile::from_json(args.profile, &configuration) {
        Ok(profile) => profile,
        Err(e) => {
            eprintln!("Failed to parse the configuration: {}", e);
            std::process::exit(1);
        }
    };

    // If we're not saving the profile, just print it and exit.
    if !args.save {
        println!("{}", profile);
        return Ok(())
    }

    if !config_dir.exists() {
        std::fs::create_dir_all(config_dir)?;
    }

    if profile_path.exists() && !args.force {
        eprintln!("Profile {} already exists. Use --force to overwrite.", &filename);
        std::process::exit(1);
    }

    std::fs::write(&profile_path, profile.to_string())?;
    eprintln!("Profile saved to {}", profile_path.display());

    Ok(())
}
