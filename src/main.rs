use core::fmt;
use std::{io::Read, ops::Deref, path::PathBuf, process::Command};

use clap::Parser;

mod output;
mod utils;

use output::{Output, Profile};
use serde::Deserialize;

fn load_configuration_from_ipc() -> Result<String, Box<dyn std::error::Error>> {
    let Ok(output) = Command::new("swaymsg").args(["-t", "get_outputs", "--raw"]).output() else {
        eprintln!("Failed to run 'swaymsg -t get_outputs', do you have sway installed?");
        std::process::exit(1);
    };

    Ok(String::from_utf8(output.stdout)?)
}

/// Get the configuration from the given source.
///
/// If the source is None, the configuration is read from the sway IPC.
fn get_configuration(source: Option<&str>) -> Result<String, Box<dyn std::error::Error>> {
    let Some(filename) = source else {
        return load_configuration_from_ipc();
    };

    let mut result = String::new();

    if filename == "-" {
        std::io::stdin().read_to_string(&mut result)?;
    } else {
        std::fs::File::open(filename)?.read_to_string(&mut result)?;
    };

    Ok(result)
}

#[derive(Parser)]
struct Args {
    /// The name of the new profile.
    profile: String,

    /// Save the profile to the configuration directory.
    #[clap(short, long)]
    save: bool,

    /// When saving, allow overwriting an existing profile of the same name.
    #[clap(short, long)]
    force: bool,

    /// The suffix added to the profile filename when saving.
    #[clap(long, default_value = ".conf")]
    suffix: String,

    /// The directory where the profile should be saved.
    #[clap(short, long, default_value_t = ClapPath(dirs::config_dir().map(|v| v.join("kanshi/config.d"))))]
    config_dir: ClapPath,

    /// The input file to read the current display configuration from. The file should be valid
    /// JSON created from `swaymsg -t get_outputs --raw`.
    ///
    /// If not specified, the configuration is fetched automatically from the Sway IPC. If the
    /// input file is `-`, the configuration is instead read from stdin.
    #[clap(long)]
    from_file: Option<String>,

    /// Show where the profile generated by a given invocation would be saved, if --save is used.
    ///
    /// The profile will not be saved if this flag is used.
    #[clap(short, long)]
    location: bool,
}

/// A wrapper around a `Option<PathBuf>` that implements `From<&str>` and `Display` so that Clap is
/// happy.
#[derive(Debug, Clone, Deserialize)]
struct ClapPath(Option<PathBuf>);

impl Deref for ClapPath {
    type Target = Option<PathBuf>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<&str> for ClapPath {
    fn from(s: &str) -> Self {
        ClapPath(Some(PathBuf::from(s)))
    }
}

impl fmt::Display for ClapPath {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match &self.0 {
            Some(path) => write!(f, "{}", path.display()),
            None => write!(f, "None"),
        }
    }
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args = Args::parse();

    if args.force && !args.save {
        eprintln!("The --force flag cannot be used without --save.");
        std::process::exit(1);
    }

    let filename = format!("{}{}", &args.profile, args.suffix);
    let config_dir = args.config_dir.as_ref().expect("a config directory was able to be determined");
    let profile_path = config_dir.join(&filename);

    if args.location {
        println!("{}", profile_path.display());
        return Ok(());
    }

    let configuration = get_configuration(args.from_file.as_deref())?;
    let outputs = match serde_json::from_str::<Vec<Output>>(&configuration) {
        Ok(outputs) => outputs,
        Err(e) => {
            eprintln!("Failed to parse the configuration: {}", e);
            std::process::exit(1);
        }
    };

    let profile = Profile {
        name: args.profile,
        outputs,
    };

    // If we're not saving the profile, just print it and exit.
    if !args.save {
        println!("{}", profile);
        return Ok(())
    }

    if !config_dir.exists() {
        std::fs::create_dir_all(config_dir)?;
    }

    if profile_path.exists() && !args.force {
        eprintln!("Profile {} already exists. Use --force to overwrite.", &filename);
        std::process::exit(1);
    }

    std::fs::write(&profile_path, profile.to_string())?;
    eprintln!("Profile saved to {}", profile_path.display());

    Ok(())
}
